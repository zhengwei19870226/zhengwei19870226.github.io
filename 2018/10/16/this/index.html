<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>this深入学习 | Vivi&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="javascript中的this，是一个在每个函数作用域中自动定义的特殊标识符关键字。 this指向this不是代码编写时绑定，而是运行时绑定。它依赖于函数调用的上下文，this指向与函数声明的位置没有任何关系，只与函数被调用的方式紧密相关。 当一个函数被调用时，会建立一个被称为执行环境的活动记录，记录包含函数是从何处（调用栈）被调用，如何被调用，传递什么参数等信息。这个记录的属性之一，就是在函数">
<meta property="og:type" content="article">
<meta property="og:title" content="this深入学习">
<meta property="og:url" content="http://yoursite.com/2018/10/16/this/index.html">
<meta property="og:site_name" content="Vivi&#39;s Blog">
<meta property="og:description" content="javascript中的this，是一个在每个函数作用域中自动定义的特殊标识符关键字。 this指向this不是代码编写时绑定，而是运行时绑定。它依赖于函数调用的上下文，this指向与函数声明的位置没有任何关系，只与函数被调用的方式紧密相关。 当一个函数被调用时，会建立一个被称为执行环境的活动记录，记录包含函数是从何处（调用栈）被调用，如何被调用，传递什么参数等信息。这个记录的属性之一，就是在函数">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-11-21T04:22:27.667Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="this深入学习">
<meta name="twitter:description" content="javascript中的this，是一个在每个函数作用域中自动定义的特殊标识符关键字。 this指向this不是代码编写时绑定，而是运行时绑定。它依赖于函数调用的上下文，this指向与函数声明的位置没有任何关系，只与函数被调用的方式紧密相关。 当一个函数被调用时，会建立一个被称为执行环境的活动记录，记录包含函数是从何处（调用栈）被调用，如何被调用，传递什么参数等信息。这个记录的属性之一，就是在函数">
  
    <link rel="alternate" href="/atom.xml" title="Vivi&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Vivi&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-this" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/this/" class="article-date">
  <time datetime="2018-10-16T04:07:49.476Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      this深入学习
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>javascript中的this，是一个在每个函数作用域中自动定义的特殊标识符关键字。</p>
<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>this不是代码编写时绑定，而是运行时绑定。它依赖于函数调用的上下文，this指向与函数声明的位置没有任何关系，只与函数被调用的方式紧密相关。</p>
<p>当一个函数被调用时，会建立一个被称为执行环境的活动记录，记录包含函数是从何处（调用栈）被调用，如何被调用，传递什么参数等信息。这个记录的属性之一，就是在函数执行期间将被使用的this引用。</p>
<p>this是函数被调用时建立的一个绑定t，它指向什么完全由函数被调用的调用点决定。</p>
<h3 id="为什么使用this"><a href="#为什么使用this" class="headerlink" title="为什么使用this"></a>为什么使用this</h3><p>使用this可以实现一个函数对多个环境对象的复用，不需要针对每个对象定义函数的分离版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function speak() &#123;</span><br><span class="line">	console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var me = &#123;name: &quot;Kyle&quot;&#125;;</span><br><span class="line">var you = &#123;name: &quot;Reader&quot;&#125;;</span><br><span class="line"></span><br><span class="line">speak.call(me); // Kyle</span><br><span class="line">speak.call(you); // Reader</span><br></pre></td></tr></table></figure>
<h4 id="对于this的常见错误理解"><a href="#对于this的常见错误理解" class="headerlink" title="对于this的常见错误理解"></a>对于this的常见错误理解</h4><ul>
<li>第一种常见的错误理解是认为this指向函数自己。</li>
</ul>
<p>在this指向中已经明确说明了this是在运行时绑定，不是代码编写时绑定。</p>
<p>看下面的代码，foo被调用了多少次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function foo(num) &#123;</span><br><span class="line">	console.log(&quot;foo:&quot; + num);</span><br><span class="line">	</span><br><span class="line">	this.count++; //追踪foo被调用了多少次</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = 0;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">	if (i &gt; 5) &#123;</span><br><span class="line">		foo(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// foo:6</span><br><span class="line">// foo:7</span><br><span class="line">// foo:8</span><br><span class="line">// foo:9</span><br><span class="line"></span><br><span class="line">console.log(foo.count) // 0 为什么？？？</span><br></pre></td></tr></table></figure>
<p>四次输出说明foo被调用了4次，但是foo.count却是0，为什么呢？</p>
<p>当代码执行 foo.count = 0 时，它确实向函数对象 foo 添加了一个 count 属性。但是对于函数内部的 this.count 引用，this根本就不指向foo，所以这里不会输出4</p>
<p>foo被调用时的上下文是window，所以这里递增的count属性是window的，而window中没有定义一个count属性，此时windown.count是undefined，当对它执行自加操作后windown.count的值为NaN</p>
<p>如果想统计foo的被调用次数，我们该怎么做呢，可以通过更改foo的调用代码改变this指向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(i) --&gt; foo.call(foo, i)</span><br></pre></td></tr></table></figure>
<ul>
<li>对this的第二常见误解，是它不知怎的指向了函数的作用域。</li>
</ul>
<p>明确的说，this不会以任何方式指向函数的词法作用域。</p>
<p>下面的代码企图用this来隐含地引用函数的词法作用域：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	var a = 2;</span><br><span class="line">	this.bar();</span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123;</span><br><span class="line">	console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line">foo(); // undefined</span><br></pre></td></tr></table></figure>
<p>这段代码试图用this在foo()和bar()中建立一座桥，使得bar()可以访问foo()中的局部变量a，这样的桥的是可能的。不能使用this引用在此法作用域中查找东西。</p>
<h3 id="调用点"><a href="#调用点" class="headerlink" title="调用点"></a>调用点</h3><p>调用点是指函数在代码中被调用的位置，要想清楚this指向什么，首要要明确调用点，某些特定的编码模式会使真正的调用点不那么明确。</p>
<p>因此清楚函数的调用栈是十分重要的，我们关心的调用点就位于当前指向函数之前的调用。</p>
<p>通过代码看一下调用栈和调用点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function baz() &#123;</span><br><span class="line">	// 调用栈是: baz</span><br><span class="line">	// 调用点是全局作用于 global scope</span><br><span class="line">	</span><br><span class="line">	console.log(&quot;baz&quot;);</span><br><span class="line">	bar(); // bar的调用点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">	// 调用栈是: baz -&gt; bar</span><br><span class="line">	// 调用点位于:baz</span><br><span class="line">	</span><br><span class="line">	console.log(&quot;bar&quot;);</span><br><span class="line">	foo(); // foo的调用点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">	// 调用栈是: baz -&gt; bar -&gt;foo</span><br><span class="line">	// 调用点位于: bar</span><br><span class="line">	</span><br><span class="line">	console.log(&quot;foo&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baz(); // baz的调用点</span><br></pre></td></tr></table></figure>
<p>浏览器调试工具中可以查看某个函数的调用栈，在foo()函数的第一行设置断点，可以看到函数的调用栈，取得调用栈之后从上向下找到第二个记录点就是真正的调用点。</p>
<h3 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a>this的绑定规则</h3><p>在 JavaScript 中，影响 this 指向的绑定规则有四种：</p>
<h4 id="一、默认绑定"><a href="#一、默认绑定" class="headerlink" title="一、默认绑定"></a>一、默认绑定</h4><p>默认绑定是在没有其他规则适用时的默认规则，最常见的情况是 <strong>函数独立调用</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">var a = 2;</span><br><span class="line">foo(); // 2</span><br></pre></td></tr></table></figure>
<p>需要注意两点：</p>
<ol>
<li>在全局作用域中声明变量 var a = 2，相当于给全局对象添加了同名属性，也就是 window.a = 2;</li>
<li>foo() 是一个毫无修饰的函数引用调用，所以是默认绑定，this指向全局。默认绑定会根据 strict mode 的状态，其结果不是全局对象就是 undefined</li>
</ol>
<h4 id="二、隐含绑定"><a href="#二、隐含绑定" class="headerlink" title="二、隐含绑定"></a>二、隐含绑定</h4><p>通过改变目标对象使它自身包含一个对函数的引用，而后使用这个函数引用属性来间接地（隐含地）将 this 绑定到这个对象上。</p>
<p>这种绑定规则要考虑：调用点是否有一个上下文对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 2,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); // 2</span><br></pre></td></tr></table></figure>
<p>当函数调用的时候，拥有上下文对象的时候，this 会被绑定到该上下文对象。这里 this.a 就是 obj.a</p>
<p>注意：只有对象属性引用链的最后一层是影响调用点的。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">	a: 42,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">	a: 2,</span><br><span class="line">	obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.obj2.foo(); // 42</span><br></pre></td></tr></table></figure>
<h5 id="隐含丢失"><a href="#隐含丢失" class="headerlink" title="隐含丢失"></a>隐含丢失</h5><p>隐含绑定有时会出现绑定丢失的情况，这样就会退回到 <em>默认绑定</em> ，根据 strict mode 的状态，其结果不是全局对象就是 undefined。</p>
<ul>
<li>demo1：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 2,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bar = obj.foo;</span><br><span class="line">var a = &quot;global oop&quot;;</span><br><span class="line"></span><br><span class="line">bar(); // &quot;global oop&quot;</span><br></pre></td></tr></table></figure>
<p>bar 似乎是 obj.foo 的引用，但实际上它只是另一个 foo 本身的引用。另外，起作用的调用点是 bar()，一个毫无修饰的调用，因此默认绑定适用于这里。</p>
<ul>
<li>demo2：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doFoo(fn) &#123;</span><br><span class="line">	// fn只是foo的另一个引用</span><br><span class="line">	fn();  // &lt;-- 调用点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 2,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = &quot;global oop&quot;;</span><br><span class="line"></span><br><span class="line">doFoo(obj.foo); // &quot;global oop&quot;</span><br></pre></td></tr></table></figure>
<p>当传递一个回调函数时，参数传递仅仅是一中隐含的赋值，因为传递的是一个函数，所以是一个隐含的引用赋值。</p>
<ul>
<li>demo3： </li>
</ul>
<p>接demo2，如果接收你所传递回调的函数不是你的，而是语言内建的呢？同样的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 2,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = &quot;global oop&quot;;</span><br><span class="line"></span><br><span class="line">setTimeout(obj.foo, 100); // &quot;global oop&quot;</span><br></pre></td></tr></table></figure>
<h4 id="三、明确绑定"><a href="#三、明确绑定" class="headerlink" title="三、明确绑定"></a>三、明确绑定</h4><p>如果想强制一个函数调用使用某个特定对象作为 this 绑定，而不在这个对象上放置一个函数引用属性呢？</p>
<p>javascript中绝大多数被提供的函数，当然还有你将创建的所有的函数，都可以访问 call(..) 和 apply(..)。他们的第一个参数都是一个用于this的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(obj); //2</span><br></pre></td></tr></table></figure>
<p>通过foo.call()使用明确绑定来调用foo，强制foo中的this指向obj。</p>
<p>注意：从this绑定的角度讲，call和apply是完全一样的，两者只是在处理其他参数上的方式不同。</p>
<p>明确绑定同样存在先前提到的问题：也就是函数“丢失”自己原本的 this 绑定，或者被第三方框架覆盖，等等问题。</p>
<h5 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h5><p>硬绑定是明确绑定的一个变种。看下面一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bar = function() &#123;</span><br><span class="line">	foo.call(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // 2</span><br><span class="line">setTimeout(bar, 100); // 2</span><br><span class="line"></span><br><span class="line">bar.call(window); // 2</span><br></pre></td></tr></table></figure>
<p>硬绑定中，首先创建一个函数bar()，在它内部调用foo.call(obj)，由此强制this绑定到obj并调用foo。过后无论怎样调用bar，它总是手动使用obj调用foo。</p>
<p>用 硬绑定 将一个函数包装起来的最典型的方法，是为所有传入的参数和传出的返回值创建一个通道：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo(something) &#123;</span><br><span class="line">	console.log(this.a, something);</span><br><span class="line">	return this.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bar = function() &#123;</span><br><span class="line">	return foo.apply(obj, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = bar(3); // 2 3</span><br><span class="line">console.log(b); // 5</span><br></pre></td></tr></table></figure>
<p>另一种表达这种模式的方法是创建一个可复用的帮助函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function foo(something) &#123;</span><br><span class="line">	console.log(this.a, something);</span><br><span class="line">	return this.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//简单的bind帮助函数</span><br><span class="line">function bind(fn, obj) &#123;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		return fn.apply(obj, arguments);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bar = bind(foo, obj);</span><br><span class="line"></span><br><span class="line">var b = bar(3); // 2 3</span><br><span class="line">console.log(b); // 5</span><br></pre></td></tr></table></figure>
<p>由于硬绑定如此常用，所以已经作为ES5的内建工具提供：Function.prototype.bind，bind()返回一个硬编码的新函数，它使用你指定的this来调用原来的函数。使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo(something) &#123;</span><br><span class="line">	console.log(this.a, something);</span><br><span class="line">	return this.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bar = foo.bind(obj);</span><br><span class="line"></span><br><span class="line">var b = bar(3); // 2 3</span><br><span class="line">console.log(b); // 5</span><br></pre></td></tr></table></figure>
<p>注意：ES6中，bind()生成的硬绑定函数有一个name属性，如bar = foo.bind(obj)会有一个name属性，即bar.name = “bound foo”。</p>
<h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><p>在javascript中，所有的函数都可以在前面加上new来调用，使得函数调用成为一个构造器调用。实际上不存在“构造器函数”，而只有函数的构造器调用。</p>
<p>当函数通过 new 调用时，会经历以下4个步骤：</p>
<ol>
<li>创建一个全新的对象</li>
<li>设置原型链</li>
<li>新构建的对象被设置为函数调用的this绑定</li>
<li>除非函数返回一个它自己的其他 对象，否则这个被 new 调用的函数将 自动 返回这个新构建的对象。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var Func = function() &#123;&#125;;</span><br><span class="line">var func = new Func();</span><br></pre></td></tr></table></figure>
<p>对应四个步骤的代码解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">obj.__proto__ = Func.prototype;</span><br><span class="line">var result = Func.call(obj);</span><br><span class="line">if (typeof(result) == &quot;object&quot;) &#123;</span><br><span class="line">	func = result;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	func = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一切皆有顺序"><a href="#一切皆有顺序" class="headerlink" title="一切皆有顺序"></a>一切皆有顺序</h4><p>如果调用点上有多种this的绑定规则，怎么确定优先级呢？</p>
<p>显然默认绑定的优先级最低，明确绑定和 new 绑定的优先级都高于隐含绑定，那么明确绑定和 new 绑定的优先级怎么确定呢？</p>
<p>由于new和call/apply不能同时使用，所以不能直接对比new绑定和明确绑定的优先级，但是可以使用硬绑定来对比和new绑定的优先级。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo(something) &#123;</span><br><span class="line">	this.a = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var bar = foo.bind( obj1 );</span><br><span class="line">bar( 2 );</span><br><span class="line">console.log( obj1.a ); // 2</span><br><span class="line"></span><br><span class="line">var baz = new bar( 3 );</span><br><span class="line">console.log( obj1.a ); // 2</span><br><span class="line">console.log( baz.a ); // 3</span><br></pre></td></tr></table></figure>
<p>bar 是硬绑定到 obj1 的，但是 new bar(3) 并没有将 obj1.a 变为 3。反而，硬绑定到 obj1 的 bar(..) 调用可以被 new 所覆盖。因为 new 被实施，我们得到一个名为 baz 的新创建的对象，baz.a 的值为 3</p>
<p>结论：硬绑定的优先级高于new绑定，并且不能被new覆盖。</p>
<h3 id="判定this"><a href="#判定this" class="headerlink" title="判定this"></a>判定this</h3><p>我们可以按照以下步骤来判定this指向：</p>
<ol>
<li>函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var bar = new foo()</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var bar = foo.call( obj2 )</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>函数是通过上下文对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个上下文对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var bar = obj1.foo()</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var bar = foo()</span><br></pre></td></tr></table></figure>
<p>以上，就是理解对于普通的函数调用来说的 this 绑定规则 所需的全部，几乎是全部。</p>
<h3 id="词法this"><a href="#词法this" class="headerlink" title="词法this"></a>词法this</h3><p>ES6中引入了一种不适用于以上绑定规则特殊的函数：箭头函数（arrow-function）。</p>
<p>箭头函数从封闭它的作用域采用this绑定。</p>
<p>下面看一下箭头函数的词法作用域：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	return (a) =&gt; &#123;</span><br><span class="line">		console.log(this.a);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">	a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">	a: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bar = foo.call(obj1);</span><br><span class="line">bar.call(obj2); // 2</span><br></pre></td></tr></table></figure>
<p>在foo()中创建的箭头函数在此法上捕获foo()被调用时的this。因为foo()被this绑定到obj1，bar作为箭头函数返回的一个引用也会被this绑定到obj1。</p>
<p>注意：箭头函数的this绑定是不能被覆盖的！即便是new也不行！</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>判定this指向需要找到函数的直接调用点，然后在调用点按以下优先顺序匹配4种绑定规则：</p>
<ol>
<li>通过new调用？使用新构建的对象。</li>
<li>通过call/apply或bind调用？使用指定的对象。</li>
<li>通过上下文对象调用？使用哪个上下文对象。</li>
<li>默认绑定，严格模式下是undefied，非严格模式下是全局对象。</li>
</ol>
<p>与上述4种绑定规则不同，ES6的箭头函数使用词法作用域来决定 this 绑定，即而箭头函数的this指向声明时所在的父作用域。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch1.md" target="_blank" rel="noopener">You Don’t Know JS: this Or That?</a></p>
<p><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md" target="_blank" rel="noopener">You Don’t Know JS: this All Makes Sense Now!</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/16/this/" data-id="cjoxp4m600002tw5ui9sa57e4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/10/16/设计模式之观察者模式/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          设计模式之 观察者模式
        
      </div>
    </a>
  
  
    <a href="/2018/10/16/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/16/hello-world的副本/">正则表达式</a>
          </li>
        
          <li>
            <a href="/2018/10/16/设计模式之观察者模式/">设计模式之 观察者模式</a>
          </li>
        
          <li>
            <a href="/2018/10/16/this/">this深入学习</a>
          </li>
        
          <li>
            <a href="/2018/10/16/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/10/16/前端测试/">前端测试</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Vivi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>